// Package sdk provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package sdk

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/pkg/errors"
)

// AddNodeResult defines model for AddNodeResult.
type AddNodeResult struct {

	// id of the created note
	NodeId string `json:"nodeId"`

	// id for long running operation
	OperationId string `json:"operationId"`
}

// AddonsConfig defines model for AddonsConfig.
type AddonsConfig struct {

	// Cert-Manager
	CertManager *CertManagerConfig `json:"certManager,omitempty"`

	// Kubernetes dashboard
	Dashboard *DashboardConfig `json:"dashboard,omitempty"`

	// Elastic Cloud on Kubernetes + Logging setup
	ElasticLogging *ElasticLoggingConfig `json:"elasticLogging,omitempty"`

	// Grafana -- UI for Prometheus
	Grafana *GrafanaConfig `json:"grafana,omitempty"`

	// KEDA (keda.sh) an event-based k8s resources autoscaler
	Keda *KedaConfig `json:"keda,omitempty"`

	// Nginx-based ingress controller
	NginxIngress *NginxIngressConfig `json:"nginxIngress,omitempty"`
}

// AuditEvent defines model for AuditEvent.
type AuditEvent struct {
	Event interface{} `json:"event"`

	// type of the performed operation
	EventType string `json:"eventType"`

	// audit event id
	Id          string         `json:"id"`
	InitiatedBy AuditInitiator `json:"initiatedBy"`

	// Event creation UTC time in RFC3339 format.
	Time time.Time `json:"time"`
}

// AuditEventClusterCreated defines model for AuditEventClusterCreated.
type AuditEventClusterCreated struct {

	// snapshot of created cluster
	Cluster *map[string]interface{} `json:"cluster,omitempty"`
}

// AuditEventClusterDeleted defines model for AuditEventClusterDeleted.
type AuditEventClusterDeleted struct {

	// snapshot of deleted cluster
	Cluster *map[string]interface{} `json:"cluster,omitempty"`
}

// AuditEventList defines model for AuditEventList.
type AuditEventList struct {
	Items []AuditEvent `json:"items"`

	// Cursor token to be used in future request cursor parameter to retrieve subsequent items from the dataset. Empty value of nextCursor field indicates that there are no further items to retrieve.
	NextCursor string `json:"nextCursor"`
}

// AuditInitiator defines model for AuditInitiator.
type AuditInitiator struct {

	// email of the user (absent for system calls)
	Email *string `json:"email,omitempty"`

	// user or system ID.
	Id string `json:"id"`

	// user or system name.
	Name string `json:"name"`
}

// AuditLogEvent defines model for AuditLogEvent.
type AuditLogEvent struct {

	// Event creation UTC time in RFC3339 format.
	CreatedAt time.Time `json:"createdAt"`

	// Audit Log Event ID, generated at the time of creation.
	Id string `json:"id"`

	// Metadata about the event
	Metadata map[string]interface{} `json:"metadata"`

	// Operation.
	Operation string `json:"operation"`
}

// AuthToken defines model for AuthToken.
type AuthToken struct {

	// Indicates whether this auth token is active.
	Active bool `json:"active"`

	// Auth token creation UTC time in RFC3339 format.
	CreatedAt time.Time `json:"createdAt"`

	// Auth token deletion UTC time in RFC3339 format.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// Auth token ID, generated at the time of creation
	Id string `json:"id"`

	// Auth token last used UTC time in RFC3339 format.
	LastUsedAt *time.Time `json:"lastUsedAt,omitempty"`

	// Name of the token. Must be unique among other active tokens for the current user.
	Name string `json:"name"`
}

// AuthTokenCreateResponse defines model for AuthTokenCreateResponse.
type AuthTokenCreateResponse struct {

	// Indicates whether this auth token is active.
	Active bool `json:"active"`

	// Auth token creation UTC time in RFC3339 format.
	CreatedAt time.Time `json:"createdAt"`

	// Auth token ID, generated at the time of creation
	Id string `json:"id"`

	// Name of the token. Must be unique among other active tokens for the current user.
	Name string `json:"name"`

	// Generated secret for this auth token (only shown once on creation)
	Token string `json:"token"`
}

// AuthTokenList defines model for AuthTokenList.
type AuthTokenList struct {
	Items []AuthToken `json:"items"`
}

// AuthTokenUpdateRequest defines model for AuthTokenUpdateRequest.
type AuthTokenUpdateRequest struct {

	// Indicates whether this auth token is active.
	Active bool `json:"active"`
}

// CastRegion defines model for CastRegion.
type CastRegion struct {

	// List of available cloud providers in given CAST AI region.
	Clouds []Cloud `json:"clouds"`

	// display name of the region, e.g. `US West ( California )`.
	DisplayName string `json:"displayName"`

	// CAST AI region name, e.g. `us-west`.
	Name string `json:"name"`
}

// CastRegionList defines model for CastRegionList.
type CastRegionList struct {
	Items []CastRegion `json:"items"`
}

// CertManagerConfig defines model for CertManagerConfig.
type CertManagerConfig struct {

	// Whether this addon is enabled
	Enabled bool `json:"enabled"`
}

// Cloud defines model for Cloud.
type Cloud struct {

	// Cloud provider name.
	Name string `json:"name"`
}

// CloudCredentials defines model for CloudCredentials.
type CloudCredentials struct {

	// Cloud type that these credentials represent.
	Cloud string `json:"cloud"`

	// Actual credentials data of given cloud.
	Credentials string `json:"credentials"`

	// Credential expiration UTC time in RFC3339 format.
	ExpiresAt *time.Time `json:"expiresAt,omitempty"`

	// Whether credentials are under free trial.
	FreeTrial *bool `json:"freeTrial,omitempty"`

	// Id of cloud credentials item.
	Id string `json:"id"`

	// Name of cloud credentials object.
	Name   string                         `json:"name"`
	UsedBy *[]CloudCredentialsReservation `json:"usedBy,omitempty"`
}

// CloudCredentialsList defines model for CloudCredentialsList.
type CloudCredentialsList struct {
	Items []CloudCredentials `json:"items"`
}

// CloudCredentialsReservation defines model for CloudCredentialsReservation.
type CloudCredentialsReservation struct {

	// Id of the object which uses credentials.
	Id string `json:"id"`

	// Name of the object which uses credentials.
	Name string `json:"name"`
}

// CloudType defines model for CloudType.
type CloudType string

// List of CloudType
const (
	CloudType_aws   CloudType = "aws"
	CloudType_azure CloudType = "azure"
	CloudType_do    CloudType = "do"
	CloudType_gcp   CloudType = "gcp"
)

// ClusterCostEstimate defines model for ClusterCostEstimate.
type ClusterCostEstimate struct {
	PerCloud *CostsPerProviderEstimate `json:"perCloud,omitempty"`
	PerType  *CostsPerTypeEstimate     `json:"perType,omitempty"`

	// Estimated Price
	Total *EstimatedPriceAmount `json:"total,omitempty"`
}

// ClusterHealth defines model for ClusterHealth.
type ClusterHealth struct {
	Cilium     ClusterHealthCilium     `json:"cilium"`
	Kubernetes ClusterHealthKubernetes `json:"kubernetes"`
	Nodes      ClusterHealthNodes      `json:"nodes"`
}

// ClusterHealthCilium defines model for ClusterHealthCilium.
type ClusterHealthCilium struct {
	Msg   string `json:"msg"`
	State string `json:"state"`
}

// ClusterHealthKubernetes defines model for ClusterHealthKubernetes.
type ClusterHealthKubernetes struct {
	Msg   string `json:"msg"`
	State string `json:"state"`
}

// ClusterHealthNode defines model for ClusterHealthNode.
type ClusterHealthNode struct {
	HostIp string `json:"hostIp"`
	Name   string `json:"name"`
	State  string `json:"state"`
}

// ClusterHealthNodes defines model for ClusterHealthNodes.
type ClusterHealthNodes struct {
	Items []ClusterHealthNode `json:"items"`
	Msg   string              `json:"msg"`
}

// ClusterLimitsCpu defines model for ClusterLimitsCpu.
type ClusterLimitsCpu struct {

	// Defines the maximum allowed amount of vCPUs in the whole cluster.
	MaxCores int64 `json:"maxCores"`

	// Defines the minimum allowed amount of vCPUs in the whole cluster.
	MinCores int64 `json:"minCores"`
}

// ClusterLimitsPolicy defines model for ClusterLimitsPolicy.
type ClusterLimitsPolicy struct {

	// Defines the minimum and maximum amount of vCPUs for cluster's worker nodes.
	Cpu ClusterLimitsCpu `json:"cpu"`

	// Enable/disable cluster size limits policy.
	Enabled bool `json:"enabled"`
}

// ClusterMetrics defines model for ClusterMetrics.
type ClusterMetrics struct {

	// The query result data.
	Data *struct {

		// Sample data array based. Format is based on the result type. Check the Prometheus API docs.
		Result *[]map[string]interface{} `json:"result,omitempty"`

		// The format of the result data.
		ResultType *string `json:"resultType,omitempty"`
	} `json:"data,omitempty"`

	// Only set if status is "error". The error message.
	Error *string `json:"error,omitempty"`

	// Only set if status is "error". The data field may still hold additional data.
	ErrorType *string `json:"errorType,omitempty"`

	// Whether the metrics query was successful
	Status *string `json:"status,omitempty"`

	// Only if there were warnings while executing the request. There will still be data in the data field.
	Warnings *[]string `json:"warnings,omitempty"`
}

// ClusterRegion defines model for ClusterRegion.
type ClusterRegion struct {

	// display name of the region, e.g. `US West ( California )`.
	DisplayName string `json:"displayName"`

	// CAST AI region name, e.g. `us-west`.
	Name string `json:"name"`
}

// CostsPerProviderEstimate defines model for CostsPerProviderEstimate.
type CostsPerProviderEstimate struct {

	// Break down by provider
	Details      *[]EstimatedComponentPrice `json:"details,omitempty"`
	TotalHourly  string                     `json:"totalHourly"`
	TotalMonthly *string                    `json:"totalMonthly,omitempty"`
}

// CostsPerTypeEstimate defines model for CostsPerTypeEstimate.
type CostsPerTypeEstimate struct {
	AdditionalProperties map[string]EstimatedComponentTypePrice `json:"-"`
}

// CreateCluster defines model for CreateCluster.
type CreateCluster struct {
	Addons *AddonsConfig `json:"addons,omitempty"`

	// Credentials ID list which determines the CSP configuration of this cluster.
	CloudCredentialsIDs []string `json:"cloudCredentialsIDs"`

	// Name of this infrastructure object. Needs to be unique per organization.
	Name    string   `json:"name"`
	Network *Network `json:"network,omitempty"`

	// Initial nodes of this cluster. Must contain final masters count.
	Nodes []Node `json:"nodes"`

	// CAST AI region to create the cluster in.
	Region string `json:"region"`
}

// DashboardConfig defines model for DashboardConfig.
type DashboardConfig struct {

	// Whether this addon is enabled
	Enabled bool `json:"enabled"`
}

// DeleteNodeResult defines model for DeleteNodeResult.
type DeleteNodeResult struct {

	// id for long running operation
	OperationId string `json:"operationId"`
}

// DeletedNode defines model for DeletedNode.
type DeletedNode struct {

	// specifies how long should drain be attempted (in seconds).
	DrainTimeout *int `json:"drain_timeout,omitempty"`

	// when set to false, node deletion will be aborted if drain timeout expires.
	Force *bool `json:"force,omitempty"`

	// node ID autogenerated at the time of node creation
	Id string `json:"id"`
}

// ElasticLoggingConfig defines model for ElasticLoggingConfig.
type ElasticLoggingConfig struct {
	Config *struct {
		HaMode *string `json:"haMode,omitempty"`
	} `json:"config,omitempty"`

	// Whether this addon is enabled
	Enabled bool `json:"enabled"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {

	// in case the error is related to specific field, this list will contain
	FieldViolations []FieldViolation `json:"fieldViolations"`
	Message         string           `json:"message"`
}

// EstimatedComponentPrice defines model for EstimatedComponentPrice.
type EstimatedComponentPrice struct {

	// Price for all of the components instances. Contains dependencies breakdown
	Dependencies *EstimatedComponentPrice `json:"dependencies,omitempty"`

	// Estimated Price
	FullPrice EstimatedPriceAmount `json:"fullPrice"`

	// component's string id, e.g. "vpn", "master", "worker" and so on
	Id string `json:"id"`

	// human-readable component's name
	Name      string `json:"name"`
	UnitCount int    `json:"unitCount"`

	// Estimated Price
	UnitPrice EstimatedPriceAmount `json:"unitPrice"`
}

// EstimatedComponentTypePrice defines model for EstimatedComponentTypePrice.
type EstimatedComponentTypePrice struct {

	// Estimated Price
	Price     *EstimatedPriceAmount `json:"price,omitempty"`
	UnitCount *int                  `json:"unitCount,omitempty"`
}

// EstimatedPriceAmount defines model for EstimatedPriceAmount.
type EstimatedPriceAmount struct {

	// ISO-4217 currency code
	CurrencyCode *string `json:"currencyCode,omitempty"`

	// Price per hour (e.g. "0.1234")
	Hourly *string `json:"hourly,omitempty"`

	// Price in dollars per month (30 days, e.g. "1.234")
	Monthly *string `json:"monthly,omitempty"`
}

// FieldViolation defines model for FieldViolation.
type FieldViolation struct {
	Description string `json:"description"`
	Field       string `json:"field"`
}

// GSLBDeleteRequest defines model for GSLBDeleteRequest.
type GSLBDeleteRequest struct {

	// ID of the cluster.
	ClusterId string `json:"clusterId"`

	// Name of the exposed LoadBalancer type service.
	ServiceName string `json:"serviceName"`

	// Namespace where the exposed LoadBalancer type service resides.
	ServiceNamespace string `json:"serviceNamespace"`
}

// GSLBRequest defines model for GSLBRequest.
type GSLBRequest struct {

	// ID of the cluster.
	ClusterId string `json:"clusterId"`

	// Array of all cloud load balancer hostnames and IP addresses which should be globally load balanced.
	Hosts []string `json:"hosts"`

	// Name of the exposed LoadBalancer type service.
	ServiceName string `json:"serviceName"`

	// Namespace where the exposed LoadBalancer type service resides.
	ServiceNamespace string `json:"serviceNamespace"`
}

// GSLBResponse defines model for GSLBResponse.
type GSLBResponse struct {

	// Hostname of the GSLB.
	Dns string `json:"dns"`
}

// GrafanaConfig defines model for GrafanaConfig.
type GrafanaConfig struct {

	// Whether this addon is enabled
	Enabled bool `json:"enabled"`
}

// Headroom defines model for Headroom.
type Headroom struct {

	// Defines percentage of additional CPU capacity to be added
	CpuPercentage int `json:"cpuPercentage"`

	// Defines percentage of additional memory capacity to be added
	MemoryPercentage int `json:"memoryPercentage"`
}

// Heartbeat defines model for Heartbeat.
type Heartbeat struct {

	// Timestamp of the last heartbeat from this system
	ReceivedAt *time.Time `json:"receivedAt,omitempty"`

	// originating system name
	System *string `json:"system,omitempty"`
}

// IngressLoadBalancer defines model for IngressLoadBalancer.
type IngressLoadBalancer struct {

	// Load balancer address.
	Address string `json:"address"`

	// Type/origin of load balancer.
	Type string `json:"type"`
}

// IpSecConfig defines model for IpSecConfig.
type IpSecConfig map[string]interface{}

// KedaConfig defines model for KedaConfig.
type KedaConfig struct {

	// Whether this addon is enabled
	Enabled bool `json:"enabled"`
}

// KubernetesCluster defines model for KubernetesCluster.
type KubernetesCluster struct {
	Addons *AddonsConfig `json:"addons,omitempty"`

	// Credentials ID list which determines the CSP configuration of this cluster.
	CloudCredentialsIDs []string `json:"cloudCredentialsIDs"`

	// Cluster creation UTC time in RFC3339 format.
	CreatedAt  *time.Time                    `json:"createdAt,omitempty"`
	Heartbeats *KubernetesCluster_Heartbeats `json:"heartbeats,omitempty"`

	// Cluster ID, generated at the time of creation
	Id string `json:"id"`

	// Cluster kubernetes version.
	KubernetesVersion *string `json:"kubernetesVersion,omitempty"`

	// Name of this infrastructure object. Needs to be unique per organization.
	Name    string   `json:"name"`
	Network *Network `json:"network,omitempty"`

	// Cluster nodes.
	Nodes []Node `json:"nodes"`

	// Optional notes added when pausing the cluster.
	PausedNotes   *string `json:"pausedNotes,omitempty"`
	ReconcileMode string  `json:"reconcileMode"`

	// CAST AI region used by cluster.
	Region ClusterRegion `json:"region"`

	// Current status of the cluster
	Status string `json:"status"`
}

// KubernetesCluster_Heartbeats defines model for KubernetesCluster.Heartbeats.
type KubernetesCluster_Heartbeats struct {
	AdditionalProperties map[string]Heartbeat `json:"-"`
}

// KubernetesClusterAuditLogEventsList defines model for KubernetesClusterAuditLogEventsList.
type KubernetesClusterAuditLogEventsList struct {
	Items []AuditLogEvent `json:"items"`
}

// KubernetesClusterFeedbackEvent defines model for KubernetesClusterFeedbackEvent.
type KubernetesClusterFeedbackEvent struct {

	// Event creation UTC time in RFC3339 format.
	CreatedAt time.Time `json:"createdAt"`

	// Cluster feedback event ID, generated at the time of creation.
	Id string `json:"id"`

	// Message of this event.
	Message string `json:"message"`

	// Severity level.
	Severity string `json:"severity"`
}

// KubernetesClusterFeedbackEventsList defines model for KubernetesClusterFeedbackEventsList.
type KubernetesClusterFeedbackEventsList struct {
	Items []KubernetesClusterFeedbackEvent `json:"items"`
}

// KubernetesClusterList defines model for KubernetesClusterList.
type KubernetesClusterList struct {
	Items []KubernetesCluster `json:"items"`
}

// KubernetesIngressController defines model for KubernetesIngressController.
type KubernetesIngressController struct {

	// Set of load balancers forwarding requests to the ingress.
	LoadBalancers []IngressLoadBalancer `json:"loadBalancers"`

	// Available ingress controller ports.
	Ports []int `json:"ports"`
}

// Network defines model for Network.
type Network struct {
	Vpn VpnConfig `json:"vpn"`
}

// NginxIngressConfig defines model for NginxIngressConfig.
type NginxIngressConfig struct {

	// Whether this addon is enabled
	Enabled bool `json:"enabled"`
}

// Node defines model for Node.
type Node struct {

	// Cloud service provider type.
	Cloud CloudType `json:"cloud"`

	// Node creation UTC time in RFC3339 format.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// Node ID autogenerated at the time of node creation.
	Id *string `json:"id,omitempty"`

	// Precise VM instance type for specific cloud. If specified, `shape` field is ignored.
	InstanceType string `json:"instanceType"`

	// Node name generated at the time of node creation.
	Name *string `json:"name,omitempty"`

	// Kubernetes node network
	Network *NodeNetwork `json:"network,omitempty"`

	// Specifies the node type.
	//
	// `master` hosts the Kubernetes control plane.
	//
	// `worker` is used to run workloads and supports autoscaling.
	Role NodeType `json:"role"`

	// CAST AI shape defining VM template. Field is required unless `instanceType` is specified.
	Shape NodeShape `json:"shape"`

	// Spot instance configuration.
	SpotConfig *NodeSpotConfig `json:"spotConfig,omitempty"`

	// Kubernetes node state.
	State *NodeState `json:"state,omitempty"`
}

// NodeDownscaler defines model for NodeDownscaler.
type NodeDownscaler struct {
	EmptyNodes *NodeDownscalerEmptyNodes `json:"emptyNodes,omitempty"`
}

// NodeDownscalerEmptyNodes defines model for NodeDownscalerEmptyNodes.
type NodeDownscalerEmptyNodes struct {

	// Defines whether Node Downscaler should opt in for removing empty worker nodes when possible.
	Enabled *bool `json:"enabled,omitempty"`
}

// NodeList defines model for NodeList.
type NodeList struct {
	Items []Node `json:"items"`
}

// NodeNetwork defines model for NodeNetwork.
type NodeNetwork struct {

	// node private IP
	PrivateIp string `json:"privateIp"`

	// node public IP
	PublicIp string `json:"publicIp"`
}

// NodeShape defines model for NodeShape.
type NodeShape string

// List of NodeShape
const (
	NodeShape__x_large NodeShape = "2x-large"
	NodeShape_large    NodeShape = "large"
	NodeShape_medium   NodeShape = "medium"
	NodeShape_small    NodeShape = "small"
	NodeShape_x_large  NodeShape = "x-large"
	NodeShape_x_small  NodeShape = "x-small"
)

// NodeSpotConfig defines model for NodeSpotConfig.
type NodeSpotConfig struct {

	// Indicates whether the node should be spot/preemtive, suitable for fault-tolerant workloads.
	//
	// `true` if instance should be Spot (AWS), Preemtible (GCP), etc.
	//
	// `false` if the node should be stable on-demand.
	IsSpot bool `json:"isSpot"`

	// Max bid price (only applicable to AWS).
	Price *string `json:"price,omitempty"`
}

// NodeState defines model for NodeState.
type NodeState struct {

	// Current status of a node.
	Phase *string `json:"phase,omitempty"`
}

// NodeType defines model for NodeType.
type NodeType string

// List of NodeType
const (
	NodeType_master NodeType = "master"
	NodeType_worker NodeType = "worker"
)

// NodeUpdateOperation defines model for NodeUpdateOperation.
type NodeUpdateOperation struct {
	Add    *[]Node        `json:"add,omitempty"`
	Delete *[]DeletedNode `json:"delete,omitempty"`
}

// OperationResponse defines model for OperationResponse.
type OperationResponse struct {

	// Operation creation time in RFC3339Nano format.
	CreatedAt time.Time `json:"createdAt"`

	// Indicates whether the operation is done. If 'true', the operation has finished. If 'false', the operation is still in progress.
	Done bool `json:"done"`

	// Error details for the operation. Only populated when the operation is done and has failed. If operation has completed successfully, the error will not be set.
	Error *struct {

		// Human readable caption text describing the error reason.
		Details string `json:"details"`

		// Reason is an operation specific failure code. Refer to documentation of the endpoint which generated the long-running operation about possible outcomes. Common error reasons:
		// * `internal_error`: An unknown error occurred. Retry the operation.
		Reason string `json:"reason"`
	} `json:"error,omitempty"`

	// Operation finishe time in RFC3339Nano format.
	FinishedAt *time.Time `json:"finishedAt,omitempty"`

	// ID of the operation.
	Id string `json:"id"`
}

// PauseCluster defines model for PauseCluster.
type PauseCluster struct {

	// Optional notes when pausing a cluster (2000 characters at most)
	Notes *string `json:"notes,omitempty"`
}

// PoliciesConfig defines model for PoliciesConfig.
type PoliciesConfig struct {

	// Defines minimum and maximum amount of vCPUs for cluster's worker nodes.
	ClusterLimits ClusterLimitsPolicy `json:"clusterLimits"`

	// Enable/disable all policies
	Enabled bool `json:"enabled"`

	// Node Downscaler defines policies for removing nodes based on the configured conditions.
	NodeDownscaler *NodeDownscaler `json:"nodeDownscaler,omitempty"`

	// Policy defining whether autoscaler can use spot instances for provisioning additional workloads.
	SpotInstances SpotInstances `json:"spotInstances"`

	// Policy defining autoscaler's behavior when unscedulable pods were detected.
	UnschedulablePods UnschedulablePodsPolicy `json:"unschedulablePods"`
}

// ResourceUsage defines model for ResourceUsage.
type ResourceUsage struct {

	// cpu hours used for given date.
	Cpu int `json:"cpu"`

	// start of usage time in RFC3339 format.
	From string `json:"from"`

	// memory (MB) hours used for given date.
	Memory int `json:"memory"`

	// end of usage time in RFC3339 format.
	To string `json:"to"`
}

// ResourceUsageReport defines model for ResourceUsageReport.
type ResourceUsageReport struct {
	Dates []ResourceUsage `json:"dates"`

	// reported usage has occurred after this date. RFC3339 format.
	FromDate string `json:"fromDate"`

	// reported usage has occurred before this date. RFC3339 format.
	ToDate string `json:"toDate"`
}

// SpotInstances defines model for SpotInstances.
type SpotInstances struct {

	// Enable/disable spot instances policy.
	Clouds []string `json:"clouds"`

	// Enable/disable spot instances policy.
	Enabled bool `json:"enabled"`
}

// UnschedulablePodsPolicy defines model for UnschedulablePodsPolicy.
type UnschedulablePodsPolicy struct {

	// Enable/disable unschedulable pods detection policy.
	Enabled bool `json:"enabled"`

	// Additional headroom based on cluster's total available capacity.
	Headroom Headroom `json:"headroom"`
}

// UserProfile defines model for UserProfile.
type UserProfile struct {

	// user email
	Email string `json:"email"`

	// full name of logged-in user, e.g. "John Doe".
	Name string `json:"name"`

	// internal username. globally unique
	Nickname string             `json:"nickname"`
	Survey   *UserProfileSurvey `json:"survey,omitempty"`
}

// UserProfileSurvey defines model for UserProfileSurvey.
type UserProfileSurvey struct {

	// current cloud spend in USD
	AnnualCloudBudget *int    `json:"annualCloudBudget,omitempty"`
	CompanyName       *string `json:"companyName,omitempty"`
	MonthlyCpuUsage   *int    `json:"monthlyCpuUsage,omitempty"`
	Submitted         *bool   `json:"submitted,omitempty"`
}

// UserSession defines model for UserSession.
type UserSession struct {

	// corresponds to Auth0 JWT claim
	Email string `json:"email"`

	// full name of logged-in user, e.g. "John Doe". Managed by Auth0 and directly taken from login JWT claim "name".
	Name string `json:"name"`

	// corresponds to Auth0 JWT claim
	Nickname string `json:"nickname"`

	// corresponds to Auth0 JWT claim
	Picture string `json:"picture"`

	// user identity verification - salted SHA256 hash of user ID. For use with Intercom identity verification (see https://www.intercom.com/help/en/articles/183-enable-identity-verification-for-web-and-mobile)
	UserHash string `json:"userHash"`

	// user id of logged in user.
	UserId string `json:"userId"`
}

// VpnConfig defines model for VpnConfig.
type VpnConfig struct {
	IpSec     *IpSecConfig     `json:"ipSec,omitempty"`
	WireGuard *WireGuardConfig `json:"wireGuard,omitempty"`
}

// WireGuardConfig defines model for WireGuardConfig.
type WireGuardConfig struct {
	Topology string `json:"topology"`
}

// MetricsType defines model for MetricsType.
type MetricsType string

// List of MetricsType
const (
	MetricsType_cloud_cpu_requests    MetricsType = "cloud_cpu_requests"
	MetricsType_cloud_cpu_usage       MetricsType = "cloud_cpu_usage"
	MetricsType_cloud_memory_requests MetricsType = "cloud_memory_requests"
	MetricsType_cloud_memory_usage    MetricsType = "cloud_memory_usage"
	MetricsType_cloud_pods            MetricsType = "cloud_pods"
	MetricsType_node_cpu_requests     MetricsType = "node_cpu_requests"
	MetricsType_node_cpu_usage        MetricsType = "node_cpu_usage"
	MetricsType_node_memory_requests  MetricsType = "node_memory_requests"
	MetricsType_node_memory_usage     MetricsType = "node_memory_usage"
)

// AuthTokenId defines model for authTokenId.
type AuthTokenId string

// ClusterId defines model for clusterId.
type ClusterId string

// CredentialsId defines model for credentialsId.
type CredentialsId string

// Cursor defines model for cursor.
type Cursor string

// FilterClusterId defines model for filterClusterId.
type FilterClusterId string

// FilterFromDate defines model for filterFromDate.
type FilterFromDate string

// FilterToDate defines model for filterToDate.
type FilterToDate string

// Limit defines model for limit.
type Limit int

// ReturnTo defines model for returnTo.
type ReturnTo string

// ListAuditEventsParams defines parameters for ListAuditEvents.
type ListAuditEventsParams struct {

	// A limit on the number of objects to be returned, between 1 and 500. Default is 10.
	Limit *Limit `json:"limit,omitempty"`

	// A cursor for use in pagination. This is a token that defines your place in the list. For instance, if you make a list request - you will receive nextCursor field in response metadata. Given that nextCursor field is not empty, it can be used as a cursor query parameter to get subsequent items. If nextCursor is empty - there are no more items to retrieve.
	Cursor *Cursor `json:"cursor,omitempty"`

	// Request filter parameter declaring point of time after which the results should be returned. Moment in time must be declared in RFC3339 format. https://tools.ietf.org/html/rfc3339
	FromDate *FilterFromDate `json:"fromDate,omitempty"`

	// Request filter parameter declaring point of time until which the results should be returned. Moment in time must be declared in RFC3339 format. https://tools.ietf.org/html/rfc3339
	ToDate *FilterToDate `json:"toDate,omitempty"`

	// Request filter parameter representing unique cluster ID. For instance, if you make a list request with clusterId filter parameter - returned results will represent the respective cluster. Cluster ID must be a valid UUID.
	ClusterId *FilterClusterId `json:"clusterId,omitempty"`
}

// LoginParams defines parameters for Login.
type LoginParams struct {

	// URL to redirect browser to after operation completes
	ReturnTo *ReturnTo `json:"returnTo,omitempty"`

	// optional override for URL to redirect browser from auth0 back to backend, for situations where backend is being reached via proxy
	Auth0returnTo *string `json:"auth0returnTo,omitempty"`

	// optional hint for which screen to use when redirecting to authentication pages.
	ScreenHint *string `json:"screenHint,omitempty"`
}

// LogoutParams defines parameters for Logout.
type LogoutParams struct {

	// URL to redirect browser to after operation completes
	ReturnTo *ReturnTo `json:"returnTo,omitempty"`
}

// CreateAuthTokenJSONBody defines parameters for CreateAuthToken.
type CreateAuthTokenJSONBody AuthToken

// UpdateAuthTokenJSONBody defines parameters for UpdateAuthToken.
type UpdateAuthTokenJSONBody AuthTokenUpdateRequest

// ChargebeeSsoParams defines parameters for ChargebeeSso.
type ChargebeeSsoParams struct {

	// Optional parameter: desired destination URL within Chargebee. See https://apidocs.chargebee.com/docs/api/portal_sessions#create_a_portal_session_forward_url for more details.
	ForwardUrl *string `json:"forwardUrl,omitempty"`
}

// PlanClusterPriceJSONBody defines parameters for PlanClusterPrice.
type PlanClusterPriceJSONBody struct {
	Addons  *AddonsConfig `json:"addons,omitempty"`
	Clouds  *[]CloudType  `json:"clouds,omitempty"`
	Network *Network      `json:"network,omitempty"`

	// Initial nodes of this cluster. Both masters and workers
	Nodes *[]Node `json:"nodes,omitempty"`

	// CAST AI region used by cluster.
	Region *ClusterRegion `json:"region,omitempty"`
}

// CreateCloudCredentialsJSONBody defines parameters for CreateCloudCredentials.
type CreateCloudCredentialsJSONBody CloudCredentials

// DeleteGslbJSONBody defines parameters for DeleteGslb.
type DeleteGslbJSONBody GSLBDeleteRequest

// CreateOrUpdateGslbJSONBody defines parameters for CreateOrUpdateGslb.
type CreateOrUpdateGslbJSONBody GSLBRequest

// ListKubernetesClustersParams defines parameters for ListKubernetesClusters.
type ListKubernetesClustersParams struct {

	// Optional parameter to query for clusters which are using the particular credentials.
	// Provide as repeated parameter in case of multiple arguments, e.g. `?credentialsId=123&credentialsId=456`.
	// Cluster will be included in the list if it's using any of the provided credentials.
	CredentialsId *[]string `json:"credentialsId,omitempty"`
}

// CreateNewClusterJSONBody defines parameters for CreateNewCluster.
type CreateNewClusterJSONBody CreateCluster

// ConfigureClusterAddonsJSONBody defines parameters for ConfigureClusterAddons.
type ConfigureClusterAddonsJSONBody AddonsConfig

// GetClusterMetricsParams defines parameters for GetClusterMetrics.
type GetClusterMetricsParams struct {

	// The type of metric to query
	MetricsType *MetricsType `json:"metricsType,omitempty"`
}

// AddClusterNodeJSONBody defines parameters for AddClusterNode.
type AddClusterNodeJSONBody Node

// CloseNodeSshJSONBody defines parameters for CloseNodeSsh.
type CloseNodeSshJSONBody struct {

	// Access rule ID used to close firewall created for SSH session.
	AccessRuleId string `json:"accessRuleId"`
}

// SetupNodeSshJSONBody defines parameters for SetupNodeSsh.
type SetupNodeSshJSONBody struct {

	// Public authorized key ed25519 for node SSH connection.
	PublicKey string `json:"publicKey"`

	// Client public source IP which will be added to firewall rules for SSH connection.
	SourceIp string `json:"sourceIp"`
}

// UpdateNodeListJSONBody defines parameters for UpdateNodeList.
type UpdateNodeListJSONBody NodeUpdateOperation

// PauseClusterJSONBody defines parameters for PauseCluster.
type PauseClusterJSONBody PauseCluster

// UpsertPoliciesJSONBody defines parameters for UpsertPolicies.
type UpsertPoliciesJSONBody PoliciesConfig

// UpdateCurrentUserProfileJSONBody defines parameters for UpdateCurrentUserProfile.
type UpdateCurrentUserProfileJSONBody UserProfile

// GetUsageReportParams defines parameters for GetUsageReport.
type GetUsageReportParams struct {

	// Request filter parameter representing unique cluster ID. For instance, if you make a list request with clusterId filter parameter - returned results will represent the respective cluster. Cluster ID must be a valid UUID.
	ClusterId *FilterClusterId `json:"clusterId,omitempty"`

	// Request filter parameter declaring point of time after which the results should be returned. Moment in time must be declared in RFC3339 format. https://tools.ietf.org/html/rfc3339
	FromDate *FilterFromDate `json:"fromDate,omitempty"`

	// Request filter parameter declaring point of time until which the results should be returned. Moment in time must be declared in RFC3339 format. https://tools.ietf.org/html/rfc3339
	ToDate *FilterToDate `json:"toDate,omitempty"`
}

// CreateAuthTokenRequestBody defines body for CreateAuthToken for application/json ContentType.
type CreateAuthTokenJSONRequestBody CreateAuthTokenJSONBody

// UpdateAuthTokenRequestBody defines body for UpdateAuthToken for application/json ContentType.
type UpdateAuthTokenJSONRequestBody UpdateAuthTokenJSONBody

// PlanClusterPriceRequestBody defines body for PlanClusterPrice for application/json ContentType.
type PlanClusterPriceJSONRequestBody PlanClusterPriceJSONBody

// CreateCloudCredentialsRequestBody defines body for CreateCloudCredentials for application/json ContentType.
type CreateCloudCredentialsJSONRequestBody CreateCloudCredentialsJSONBody

// DeleteGslbRequestBody defines body for DeleteGslb for application/json ContentType.
type DeleteGslbJSONRequestBody DeleteGslbJSONBody

// CreateOrUpdateGslbRequestBody defines body for CreateOrUpdateGslb for application/json ContentType.
type CreateOrUpdateGslbJSONRequestBody CreateOrUpdateGslbJSONBody

// CreateNewClusterRequestBody defines body for CreateNewCluster for application/json ContentType.
type CreateNewClusterJSONRequestBody CreateNewClusterJSONBody

// ConfigureClusterAddonsRequestBody defines body for ConfigureClusterAddons for application/json ContentType.
type ConfigureClusterAddonsJSONRequestBody ConfigureClusterAddonsJSONBody

// AddClusterNodeRequestBody defines body for AddClusterNode for application/json ContentType.
type AddClusterNodeJSONRequestBody AddClusterNodeJSONBody

// CloseNodeSshRequestBody defines body for CloseNodeSsh for application/json ContentType.
type CloseNodeSshJSONRequestBody CloseNodeSshJSONBody

// SetupNodeSshRequestBody defines body for SetupNodeSsh for application/json ContentType.
type SetupNodeSshJSONRequestBody SetupNodeSshJSONBody

// UpdateNodeListRequestBody defines body for UpdateNodeList for application/json ContentType.
type UpdateNodeListJSONRequestBody UpdateNodeListJSONBody

// PauseClusterRequestBody defines body for PauseCluster for application/json ContentType.
type PauseClusterJSONRequestBody PauseClusterJSONBody

// UpsertPoliciesRequestBody defines body for UpsertPolicies for application/json ContentType.
type UpsertPoliciesJSONRequestBody UpsertPoliciesJSONBody

// UpdateCurrentUserProfileRequestBody defines body for UpdateCurrentUserProfile for application/json ContentType.
type UpdateCurrentUserProfileJSONRequestBody UpdateCurrentUserProfileJSONBody

// Getter for additional properties for CostsPerTypeEstimate. Returns the specified
// element and whether it was found
func (a CostsPerTypeEstimate) Get(fieldName string) (value EstimatedComponentTypePrice, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CostsPerTypeEstimate
func (a *CostsPerTypeEstimate) Set(fieldName string, value EstimatedComponentTypePrice) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]EstimatedComponentTypePrice)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CostsPerTypeEstimate to handle AdditionalProperties
func (a *CostsPerTypeEstimate) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]EstimatedComponentTypePrice)
		for fieldName, fieldBuf := range object {
			var fieldVal EstimatedComponentTypePrice
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CostsPerTypeEstimate to handle AdditionalProperties
func (a CostsPerTypeEstimate) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for KubernetesCluster_Heartbeats. Returns the specified
// element and whether it was found
func (a KubernetesCluster_Heartbeats) Get(fieldName string) (value Heartbeat, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for KubernetesCluster_Heartbeats
func (a *KubernetesCluster_Heartbeats) Set(fieldName string, value Heartbeat) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]Heartbeat)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for KubernetesCluster_Heartbeats to handle AdditionalProperties
func (a *KubernetesCluster_Heartbeats) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]Heartbeat)
		for fieldName, fieldBuf := range object {
			var fieldVal Heartbeat
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for KubernetesCluster_Heartbeats to handle AdditionalProperties
func (a KubernetesCluster_Heartbeats) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}
